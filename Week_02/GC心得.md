(必做） 根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 的总结，提交到 Github。

程序在运行过程产生大量内存垃圾（没有引用指向的内存对象都属于内存垃圾，对象无法访问）为了确保程序运行时的性能，java虚拟机在程序运行的自动的进行垃圾回收（GC）。 GC 算法主要有下面四种：

1、引用计数算法（Reference counting） 每个对象在创建的时候，就给这个对象绑定一个计数器。每当有一个引用指向该对象时，计数器加一；每当有一个指向它的引用被删除时，计数器减一。这样，当没有引用指向该对象时，该对象死亡，计数器为0，这时就应该对这个对象进行垃圾回收操作。

2、标记–清除算法（Mark-Sweep） 为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。 分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。

3、标记–整理（压缩）算法 标记-整理法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。

4、复制算法 该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。

这个算法与标记-整理算法的区别在于，该算法不是在同一个区域复制，而是将所有存活的对象复制到另一个区域内。

垃圾回收的方式（串行，并行，CMS（并发），G1，ZGC）

Serial，单线程收集垃圾，在工作时会暂停所有的工作线程，只在单核CPU的机器上适合使用；

ParNew，多线程收集垃圾，除此之外，其余的行为、特点和Serial收集器一样，在多核CPU下比Serial收集器有优势；

Parallel Scavenge，JDK8默认的垃圾回收器，并行收集垃圾，更侧重于系统的吞吐量，而不是用户线程的停顿时间，这点较CMS不同，在堆内存分配较小的情况下，其吞吐量可能较CMS稍低，可是在堆内存足够大之后，比CMS具有明显的优势；

CMS,并发标记清除，属于老年代垃圾回收器，垃圾回收分为6个阶段，只在初始标记、重新标记这两个阶段会发生STW，其它阶段都是与用户线程并发执行，因而减少用户线程的停顿时间，使程序更平稳，更关注于用户线程的停顿时间，后面一些高级的垃圾回收器都是基于CMS作为基础来设计并实现；

G1，Garbage First，JDK9开始默认的垃圾回收器，同样采用分代收集算法，不再将堆内存分为年轻代和老年代，而是划分为2048个内存大小相同的region，G1不必每次都去回收整个堆空间，而是根据设置的停顿时间，优先去回收垃圾最多的region区，这个停顿时间也需要设置合理，如果过短，那么会导致频繁的垃圾回收。

吞吐量：

吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。 虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。